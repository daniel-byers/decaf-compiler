package decaf;

import org.antlr.v4.runtime.tree.*;
import org.antlr.v4.runtime.Token;
import java.util.*;

class DefinitionPassListener extends DecafParserBaseListener {
  //public DefinitionPassListener() {}

  ParseTreeProperty<Scope> scopes = new ParseTreeProperty<>();
  GlobalScope globalScope;
  Scope currentScope;

  public void enterProgram(DecafParser.ProgramContext ctx) {
    globalScope = new GlobalScope(null);
    currentScope = globalScope;
  }

  public void exitProgram(DecafParser.ProgramContext ctx){
    System.out.println(globalScope);
  }

  public void enterMethodDecl(DecafParser.MethodDeclContext ctx) {

    // Create a MethodSymbol to hold the name, return type, and a pointer to the enclosing scope.
    MethodSymbol newMethodScope = new MethodSymbol(ctx.methodName().IDENTIFIER().getText(), 
      Symbol.getType(ctx.type().get(0).start.getType()), currentScope);
    
    // Lists are returned from the DecafParser.java that is generated by ANTLR. List types depend
    // on whether the match was a Lexer Token (TerminalNode) or a Parser Rule (xContext). Iterators
    // are build for these lists so we can later build VariableSymbols from them.

    // There is an IDENTIFIER for each argument name passed into a method, 
    ListIterator indentifierListItr = ctx.IDENTIFIER().listIterator();

    // There is a type for all arguments, but also the method return type. Return type is in index
    // 0, so this iterator starts at index 1 until the end; capturing only the argument types.
    ListIterator indentifierTypesItr = ctx.type().listIterator(1);

    // TODO:  Check could be done here: if list lengths aren't the same then there is extraneous or
    //  --    missing operands. 

    // Iterates through both lists simultaneously, casting the return of .next() to the appropriate
    // type for creating a VariableSymbol object.
    while(indentifierListItr.hasNext() && indentifierTypesItr.hasNext()) {
      VariableSymbol newVariableSymbol = new VariableSymbol(
        ( (TerminalNode) indentifierListItr.next() ).getText(),
        Symbol.getType( ( (DecafParser.TypeContext) indentifierTypesItr.next() ).start.getType() )
      );
      newMethodScope.define(newVariableSymbol);
      System.out.println(newVariableSymbol);
    }

    // TODO:  Check could be done here: if either list has remaining items, there is extraneous or
    //  --    missing operands. 

    currentScope.define(newMethodScope);  // Define function in current scope
    scopes.put(ctx, newMethodScope);      // Push: set function's parent to current
    currentScope = newMethodScope;        // Current scope is now function scope
    // System.out.println(
    //   "method:"
    //   "variable " +
    //   indentifierListItr.next() + " of type " + 
    //   Symbol.getType( ( (DecafParser.TypeContext) indentifierTypesItr.next() ).start.getType() ) +
    //   "for method: name" + 
    // );

    // amount of identifiers should equal amount of types.
    // System.err.printf("line %d:%d %s\n", t.getLine(), t.getCharPositionInLine(), msg);
  }

  public void exitMethodDecl(DecafParser.MethodDeclContext ctx) {
    System.out.println(currentScope);
    currentScope = currentScope.getEnclosingScope();
  }

  // public void enterBlock(DecafParser.BlockContext ctx) {
  //   String name = ctx.ID().getText();
  //   int typeTokenType = ctx.type().start.getType();
  //   Symbol.Type type = CheckSymbols.getType(typeTokenType);

  //   MethodSymbol newBlockScope = new MethodSymbol(name, type, currentScope);
  //   currentScope.define(newBlockScope);
  //   scopes.put(ctx, newBlockScope);
  //   currentScope = newBlockScope;
  // }
}
// BOOK
// functionDecl: type ID '(' formalParameters? ')' block; // "void f(int x) {...}"
// formalParameters: formalParameter (',' formalParameter)*;
// formalParameter: type ID;
// type: 'float' | 'int' | 'void' ;

// MINE
// methodDecl:
//  (type | VOID) methodName LPAREN ((type IDENTIFIER COMMA?)+)? RPAREN block;
// methodName: IDENTIFIER;
// location: (IDENTIFIER | IDENTIFIER LBRACE expr RBRACE);
// type: (INT | BOOLEAN);