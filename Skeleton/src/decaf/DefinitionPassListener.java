/**
 * @author Daniel Byers | 13121312
 * 
 * This code builds on examples provided by the following book:
 * Parr, Terence (2012). The Definitive ANTLR 4 Reference. USA: The Pragmatic Bookshelf. 322.
 */

package decaf;

import org.antlr.v4.runtime.tree.*;
import org.antlr.v4.runtime.Token;
import java6G6Z1010.tools.CLI.*;
import java.util.*;

class DefinitionPassListener extends DecafParserBaseListener {

  ParseTreeProperty<Scope> scopes = new ParseTreeProperty<>();
  GlobalScope globalScope;
  Scope currentScope;

  /**
   * Creates the global scope.
   * @param ctx The ProgramContext object defined in DecafParser. Generated at compile time.
   */
  public void enterProgram(DecafParser.ProgramContext ctx) {
    globalScope = new GlobalScope(null);
    currentScope = globalScope;
  }

  /**
   * @param ctx The ProgramContext object defined in DecafParser. Generated at compile time.
   */
  public void exitProgram(DecafParser.ProgramContext ctx) {
    if (CLI.debug) System.out.println(globalScope);
  }

  /**
   * Creates global variable defined in a field declaration and adds them to the current scope.
   * @param ctx The FieldDeclContext object defined in DecafParser. Generated at compile time.
   */
  public void exitFieldDecl(DecafParser.FieldDeclContext ctx) {

    // Lists are returned from the DecafParser.java that is generated by ANTLR. List types depend
    // on whether the match was a Lexer Token (TerminalNode) or a Parser Rule (xContext). Iterators
    // are build for these lists so we can later build VariableSymbols from them.

    // There is an IDENTIFIER for each variable name; eg. a, b, etc.
    ListIterator indentifierListItr = ctx.IDENTIFIER().listIterator();

    while (indentifierListItr.hasNext()) {
      // Create a new VariableSymbol from the IDENTIFIER text and the shared type. 
      VariableSymbol newVariableSymbol = new VariableSymbol(
          ( (TerminalNode) indentifierListItr.next() ).getText(),
          Symbol.getType(ctx.type().start.getType())
      );

      // Add that symbol to the current scope.
      currentScope.define(newVariableSymbol);
    }

    ListIterator arrayIndentifierListItr = ctx.arrayDecl().listIterator();
    while (arrayIndentifierListItr.hasNext()) {
      // Retrieve the next item from the iterator and cast it to it's appropriate type.
      DecafParser.ArrayDeclContext arr_dec =
        (DecafParser.ArrayDeclContext) arrayIndentifierListItr.next();

      // Creates new ArrayVariableSymbol that holds the additional size field required by arrays.
      ArrayVariableSymbol newArrayVariableSymbol = new ArrayVariableSymbol(
        arr_dec.IDENTIFIER().getText(), Symbol.getType(ctx.type().start.getType()), 
        Integer.parseInt(arr_dec.INTLITERAL().getText()));
      
      // Add that symbol to the current scope.
      currentScope.define(newArrayVariableSymbol);      
    }
  }

  /**
   * Creates MethodSymbols that encapsulate a method, it's formal parameters and "pushes" a new
   * scope to the stack, alongside setting the current scope to the new method.
   * @param ctx The MethodDeclContext object defined in DecafParser. Generated at compile time.
   */
  public void enterMethodDecl(DecafParser.MethodDeclContext ctx) {

    // Create a MethodSymbol to hold the name, return type, and a pointer to the enclosing scope.
    MethodSymbol newMethodScope = new MethodSymbol(ctx.methodName().IDENTIFIER().getText(), 
      Symbol.getType(ctx.type().get(0).start.getType()), currentScope);

    // There is an IDENTIFIER for each argument name passed into a method, 
    ListIterator indentifierListItr = ctx.IDENTIFIER().listIterator();

    // There is a type for all arguments, but also the method return type. Return type is in index
    // 0, so this iterator starts at index 1 until the end; capturing only the argument types.
    ListIterator indentifierTypesItr = ctx.type().listIterator(1);

    // TODO:  Check could be done here: if list lengths aren't the same then there is extraneous or
    //  --    missing operands. 

    // Iterates through both lists simultaneously, casting the return of .next() to the appropriate
    // type for creating a VariableSymbol object.
    while(indentifierListItr.hasNext() && indentifierTypesItr.hasNext()) {

      // Create a VariableSymbol for each of the method's arguments
      VariableSymbol newVariableSymbol = new VariableSymbol(
        ((TerminalNode) indentifierListItr.next()).getText(),
        Symbol.getType(((DecafParser.TypeContext) indentifierTypesItr.next()).start.getType())
      );

      // Add that symbol to the methods scope
      newMethodScope.define(newVariableSymbol);
    }

    // TODO:  Check could be done here: if either list has remaining items, there is extraneous or
    //  --    missing operands. 

    // Add the new MethodSymbol to the current scope.
    currentScope.define(newMethodScope);

    // Map the new scope to the current ParseTree node in the stack of scopes.
    scopes.put(ctx, newMethodScope);

    // Set working scope to that of the method
    currentScope = newMethodScope;
  }

  /**
   * "Pops" the current scope from the stack by setting it to it's enclosing scope.
   * @param ctx The MethodDeclContext object defined in DecafParser. Generated at compile time.
   */
  public void exitMethodDecl(DecafParser.MethodDeclContext ctx) {
    if (CLI.debug) System.out.println(currentScope);
    currentScope = currentScope.getEnclosingScope();
  }

  /**
   * "Pushes" a new local scope for the block and maps the current scope to the ParseTree node.
   * @param ctx The BlockContext object defined in DecafParser. Generated at compile time.
   */
  public void enterBlock(DecafParser.BlockContext ctx) {
    currentScope = new LocalScope(currentScope);
    scopes.put(ctx, currentScope);
  }

  /**
   * "Pops" the current scope from the stack by setting it to it's enclosing scope.
   * @param ctx The BlockContext object defined in DecafParser. Generated at compile time.
   */
  public void exitBlock(DecafParser.BlockContext ctx) {
    if (CLI.debug) System.out.println(currentScope);
    currentScope = currentScope.getEnclosingScope();
  }

  /**
   * Creates VariableSymbols for each variable declaration and adds them to the current scope.
   * @param ctx The VarDeclContext object defined in DecafParser. Generated at compile time.
   */
  public void exitVarDecl(DecafParser.VarDeclContext ctx) {

    // There is an IDENTIFIER for each variable name.
    ListIterator indentifierListItr = ctx.IDENTIFIER().listIterator();

    while (indentifierListItr.hasNext()) {

      // Create a VariableSymbol for each of the method's arguments
      VariableSymbol newVariableSymbol = new VariableSymbol(
          ( (TerminalNode) indentifierListItr.next() ).getText(),
          Symbol.getType(ctx.type().start.getType())
      );

      // Add that symbol to the methods scope
      currentScope.define(newVariableSymbol);
    }
  }
}