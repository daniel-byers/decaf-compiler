/**
 * @author Daniel Byers | 13121312
 * 
 * This code builds on examples provided by the following book:
 * Parr, Terence (2012). The Definitive ANTLR 4 Reference. USA: The Pragmatic Bookshelf. 322.
 */

package decaf;

import org.antlr.v4.runtime.tree.*;
import org.antlr.v4.runtime.Token;
import org.antlr.v4.runtime.RuleContext;
import java6G6Z1010.tools.CLI.*;
import java.util.*;

class SemanticRuleManager extends DecafParserBaseListener {

  ParseTreeProperty<Scope> scopes = new ParseTreeProperty<>();
  ParseTreeProperty<Symbol.Type> exprTypes = new ParseTreeProperty<>();
  GlobalScope globalScope;
  Scope currentScope;

  /**
   * Creates the global scope.
   * @param ctx The ProgramContext object defined in DecafParser. Generated at compile time.
   */
  public void enterProgram(DecafParser.ProgramContext ctx) {
    globalScope = new GlobalScope(null);
    currentScope = globalScope;
  }

  /**
   * @param ctx The ProgramContext object defined in DecafParser. Generated at compile time.
   */
  public void exitProgram(DecafParser.ProgramContext ctx) {
    // 1. No identifier is declared twice in the same scope.
    // for (String variableName : currentScope.getDuplicates())
    //   System.out.println("Error: name " + variableName + " cannot be defined more than once.");

    // 3. The program contains a definition for a method called main that takes no parameters.
    MethodSymbol mainMethod = (MethodSymbol) currentScope.resolve("main");
    if (mainMethod == null) {
      System.out.println("Error: cannot find main()");
    } else if (!mainMethod.formalParameters.isEmpty()) {
      System.out.println("Error: main() cannot take parameters");
    }
    if (CLI.debug) System.out.println(globalScope);

  }

  /**
   * Creates global variable defined in a field declaration and adds them to the current scope.
   * @param ctx The FieldDeclContext object defined in DecafParser. Generated at compile time.
   */
  public void enterFieldDecl(DecafParser.FieldDeclContext ctx) {

    // Lists are returned from the DecafParser.java that is generated by ANTLR. List types depend
    // on whether the match was a Lexer Token (TerminalNode) or a Parser Rule (xContext). Iterators
    // are build for these lists so we can later build VariableSymbols from them.

    // There is an IDENTIFIER for each variable name; eg. a, b, etc.
    ListIterator indentifierListItr = ctx.IDENTIFIER().listIterator();

    while (indentifierListItr.hasNext()) {
      String identifierName = ( (TerminalNode) indentifierListItr.next() ).getText();

      // check to see if identifier has already been defined.
      if (currentScope.resolve(identifierName) == null) {
        // Create a new VariableSymbol from the IDENTIFIER text and the shared type.
        VariableSymbol newVariableSymbol = new VariableSymbol(identifierName,
            Symbol.getType(ctx.type().start.getType()));

        // Add that symbol to the current scope.
        currentScope.define(newVariableSymbol);
      }
      // 1. No identifier is declared twice in the same scope.
      else
        System.out.println("Error: " + identifierName + " has already been defined.");
    }

    ListIterator arrayIndentifierListItr = ctx.arrayDecl().listIterator();
    while (arrayIndentifierListItr.hasNext()) {
      // Retrieve the next item from the iterator and cast it to it's appropriate type.
      DecafParser.ArrayDeclContext arr_dec =
        (DecafParser.ArrayDeclContext) arrayIndentifierListItr.next();

      // Creates new ArrayVariableSymbol that holds the additional size field required by arrays.
      ArrayVariableSymbol newArrayVariableSymbol = new ArrayVariableSymbol(
        arr_dec.IDENTIFIER().getText(), Symbol.getType(ctx.type().start.getType()), 
        Integer.parseInt(arr_dec.INTLITERAL().getText()));
      
      // Add that symbol to the current scope.
      currentScope.define(newArrayVariableSymbol);      
    }
  }

  public void enterArrayDecl(DecafParser.ArrayDeclContext ctx) {
    // 4. The int_literal in an array declaration must be greater than 0 (negatives fail to parse).
    if (Integer.parseInt(ctx.INTLITERAL().getText()) == 0)
      System.out.println("Error: array " + ctx.IDENTIFIER() + " cannot have a size of zero");
  }

  /**
   * Creates MethodSymbols that encapsulate a method, it's formal parameters and "pushes" a new
   * scope to the stack, alongside setting the current scope to the new method.
   * @param ctx The MethodDeclContext object defined in DecafParser. Generated at compile time.
   */
  public void enterMethodDecl(DecafParser.MethodDeclContext ctx) {

    // Create a MethodSymbol to hold the name, return type, and a pointer to the enclosing scope.
    MethodSymbol newMethodScope = new MethodSymbol(ctx.methodName().IDENTIFIER().getText(), 
      Symbol.getType(ctx.type().get(0).start.getType()), currentScope);

    // There is an IDENTIFIER for each argument name passed into a method, 
    ListIterator indentifierListItr = ctx.IDENTIFIER().listIterator();

    // There is a type for all arguments, but also the method return type. Return type is in index
    // 0, so this iterator starts at index 1 until the end; capturing only the argument types.
    ListIterator indentifierTypesItr = ctx.type().listIterator(1);

    // Iterates through both lists simultaneously, casting the return of .next() to the appropriate
    // type for creating a VariableSymbol object.
    while(indentifierListItr.hasNext() && indentifierTypesItr.hasNext()) {

      // Create a VariableSymbol for each of the method's arguments
      VariableSymbol newVariableSymbol = new VariableSymbol(
        ((TerminalNode) indentifierListItr.next()).getText(),
        Symbol.getType(((DecafParser.TypeContext) indentifierTypesItr.next()).start.getType())
      );

      // Add that symbol to the methods scope
      newMethodScope.define(newVariableSymbol);
    }

    // Add the new MethodSymbol to the current scope.
    currentScope.define(newMethodScope);

    // Map the new scope to the current ParseTree node in the stack of scopes.
    scopes.put(ctx, newMethodScope);

    // Set working scope to that of the method
    currentScope = newMethodScope;
  }

  /**
   * "Pops" the current scope from the stack by setting it to it's enclosing scope.
   * @param ctx The MethodDeclContext object defined in DecafParser. Generated at compile time.
   */
  public void exitMethodDecl(DecafParser.MethodDeclContext ctx) {
    if (CLI.debug) System.out.println(currentScope);
    currentScope = currentScope.getEnclosingScope();
  }

  /**
   * "Pushes" a new local scope for the block and maps the current scope to the ParseTree node.
   * @param ctx The BlockContext object defined in DecafParser. Generated at compile time.
   */
  public void enterBlock(DecafParser.BlockContext ctx) {
    currentScope = new LocalScope(currentScope);
    scopes.put(ctx, currentScope);
  }

  /**
   * "Pops" the current scope from the stack by setting it to it's enclosing scope.
   * @param ctx The BlockContext object defined in DecafParser. Generated at compile time.
   */
  public void exitBlock(DecafParser.BlockContext ctx) {
    if (CLI.debug) System.out.println(currentScope);
    currentScope = currentScope.getEnclosingScope();
  }

  /**
   * Creates VariableSymbols for each variable declaration and adds them to the current scope.
   * @param ctx The VarDeclContext object defined in DecafParser. Generated at compile time.
   */
  public void enterVarDecl(DecafParser.VarDeclContext ctx) {
    // There is an IDENTIFIER for each variable name.
    ListIterator indentifierListItr = ctx.IDENTIFIER().listIterator();

    while (indentifierListItr.hasNext()) {
      String identifierName = ( (TerminalNode) indentifierListItr.next() ).getText();

      
      // Recursive ascent of stack from this scope to the location of the global scope. Variables
      // cannot be defined again if they have already been done so in a scope that they can see. eg.
      // foo(int a) {
      //  int a; // invalid as a is defined in formal parameters
      //  int b; // valid
      //  {
      //    int a; // invalid as a has been defined in formal parameters
      //    int b; // invalid as b has been defined in an enclosing (non-global) scope.
      //  }
      // }
      // Note: As GlobalScope is global, we don't need to check for duplicates there.
      boolean found = false;
      Scope shadowScope = currentScope;
      while (shadowScope != null ) {
        if (shadowScope.resolveLocal(identifierName) != null) found = true;

        // We want to check in every scope before global where duplicate names can exist.
        String nextScopeName = shadowScope.getEnclosingScope().getScopeName();
        if    (nextScopeName == "globals")  break;
        else                                shadowScope = shadowScope.getEnclosingScope();
      }

      if (!found) {
        // Create a new VariableSymbol from the IDENTIFIER text and the shared type.
        VariableSymbol newVariableSymbol = new VariableSymbol(identifierName,
            Symbol.getType(ctx.type().start.getType()));

        // Add that symbol to the current scope.
        currentScope.define(newVariableSymbol);
      }
      // 1. No identifier is declared twice in the same scope.
      else
        System.out.println("Error: " + identifierName + " has already been defined.");
    }
  }

  public void enterStatement(DecafParser.StatementContext ctx) {
    // As a for is encountered, a check needs to be made to see if the identifier in the expression
    // has been defined as a Symbol, and if not, create it.
    if (ctx.FOR() != null) {
      String identifierName = ctx.IDENTIFIER().getText();
      Symbol identifier = currentScope.resolve(identifierName);

      // identifier doesn't exist so we create it and define it within the current scope. The type
      // has to be an Integer
      if (identifier == null)  {
        VariableSymbol newVariableSymbol = new VariableSymbol(identifierName, Symbol.Type.INT);
        currentScope.define(newVariableSymbol);  
      }
    }
  }

  public void exitStatement(DecafParser.StatementContext ctx) {
    if (ctx.RETURN() != null) {
      // Recursive ascent of the tree from this node is necessary to locate the method in which this
      // return statement has been defined. However, the stack of Scopes cannot be modified directly
      // for this, so a shadow branch is built from this node up to the root that reflects the state
      // of the stack of scopes.
      Scope shadowScope = currentScope;
      while (shadowScope != null ) {
        // We want to stop in the scope before global, which will be the method scope that contains
        // the RETURN statement.
        String nextScopeName = shadowScope.getEnclosingScope().getScopeName();
        if    (nextScopeName == "globals")  break;
        else                                shadowScope = shadowScope.getEnclosingScope();
      }
      // This scope is a MethodSymbol object so also stores information about the return type of the
      // method.
      MethodSymbol method = (MethodSymbol) shadowScope;

      // Therefore, a checks can be made to see if the method is supposed to return a value or not.

      // 7. A return statement must not have a return value unless it appears in the body of a
      // method that is declared to return a value.
      if (method.type == Symbol.Type.VOID && ctx.expr(0) != null)
        System.out.println("Error: method " + method.name + " cannot return an expression");
      else if (method.type != Symbol.Type.VOID) {
        if (ctx.expr(0) == null)
          System.out.println("Error: method " + method.name + " return missing.");
        // 8. The expression in a return statement must have the same type as the declared result
        // type of the enclosing method definition.
        else {
          Symbol.Type exprType = exprTypes.get(ctx.expr(0));
          if (method.type != exprType)
            System.out.println("Error: " + method.name + " returned value must match return type.");
        }
      } 
    }
    else if (ctx.IF() != null) {
      Symbol.Type exprType = exprTypes.get(ctx.expr(0));
      // 11. The expr in an if statement must have type boolean.
      if (exprType != Symbol.Type.BOOLEAN)
        System.out.println("Error: if expression must be a boolean");
    }
    else if (ctx.assignOp() != null) {
      String locationName = ctx.location().IDENTIFIER().getText();
      Symbol location = (Symbol) currentScope.resolve(locationName);
      Symbol.Type exprType = exprTypes.get(ctx.expr(0));

      if (location == null)
        System.out.println("Error: variable " + locationName + " cannot be found.");
      else {
        if (ctx.assignOp().ASSIGNMENT() != null) {

          // 15. The location and expr in an assignment: `location = expr`, must have the same type.
          if (location.type != exprType)
            System.out.println("Error: incompatible types: " + exprType + " cannot be converted to "
            + location.type + "====" + locationName);

          // Technically an array can be assigned to an array index; eg `int x[1], y[2]; x[0] = y`.
          // However, since Decaf doesn't allow multi-dimensional arrays, an array index assignment
          // must be validated to ensure another array isn't the expr being assigned.

          // From DecafParser.g4: statement: ... location assignOp expr EOL ...;
          // First, a check to ensure the expr is a location
          if (ctx.expr(0).location() != null) {
            // Second, we retrieve the Symbol for the identifier.
            Symbol variable = currentScope.resolve(ctx.expr(0).location().IDENTIFIER().getText());

            // location exists and is an array, so is expr.
            // the right hand side can't be an array if the array indexes aren't present:
            // eg. `a[1] = a;` is invalid, but `a[1] = a[2]` is valid.
            if (location instanceof ArrayVariableSymbol && variable instanceof ArrayVariableSymbol){
              // Also need to ensure that if the braces for one side aren't present, the other side
              // doesn't have them too. eg. `int a[1], b[1]; a = b;` should be a valid expression.
              // So checks need to be done to ensure the sizes of the arrays are equal as well.
              // eg. `int a[5], b[3]; a = b;` should be invalid.

              // Check if LHS Array is index or not
              boolean lhsIsIndex =     ctx.location().LBRACE() != null
                                    && ctx.location().RBRACE() != null;
              // Check if RHS Array is index or not
              boolean rhsIsIndex =     ctx.expr(0).location().LBRACE() != null 
                                    && ctx.expr(0).location().RBRACE() != null;

              // left hand side is an array index but right hand side is an array
              if      (lhsIsIndex == true && rhsIsIndex == false)
                System.out.println("Error: multi-dimensional arrays are not permitted.");
              // both sides are arrays but their sizes are different.
              else if (((ArrayVariableSymbol) location).size != ((ArrayVariableSymbol) variable).size)
                System.out.println("Error: arrays can only be assigned to similar sized arrays.");
              // left hand side is an array, right hand side is an array index
              else if (lhsIsIndex == false && rhsIsIndex == true)
                System.out.println("Error: incompatible types: " + exprType + " cannot be " + 
                  "converted to " + location.type + "[]");
            }
          }
        }
        else if (ctx.assignOp().ASSIGNMENTP() != null || ctx.assignOp().ASSIGNMENTS() != null) {
          // 16. The location and the expr in an incrementing assignment: `location += expr`
          // and decrementing assignment: `location -= expr`, must be of type int.
          if (location.type != Symbol.Type.INT || exprType != Symbol.Type.INT)
            System.out.println(
              "Error: in an incrementing/decrementing assignment, operands must be of type INT; " +
              location.type + " & " + exprType + " given.");
        }
      }
    }
    else if (ctx.FOR() != null) {
      Symbol.Type expr0Type = exprTypes.get(ctx.expr(0));
      Symbol.Type expr1Type = exprTypes.get(ctx.expr(1));

      // 17. The initial expr and the ending expr of for must have type int.
      if (expr0Type != Symbol.Type.INT || expr1Type != Symbol.Type.INT)
        System.out.println("Error: both expressions in for loop must be of type INT");
    }
    else if (ctx.BREAK() != null || ctx.CONTINUE() != null) {
      // At this point a break/continue statement has been encountered. They have to be in a for.
      // A for loop is always inside a method, if we ascend the tree from this statement 
      // and reach a method declaration without first encountering a for, then we must assume that
      // the for isn't present and the break/continue is not in the right place.
      boolean foundFor = false;
      RuleContext shadowCtx = ctx;
      while (shadowCtx != null) {
        // If RuleContext is a StatementContext then see if the FOR() is null
        if (shadowCtx instanceof DecafParser.StatementContext) 
          if (((DecafParser.StatementContext) shadowCtx).FOR() != null)  foundFor = true;
        
        // Continue until we reach a method declaration.
        if    (shadowCtx instanceof DecafParser.MethodDeclContext)  break;
        else                                                        shadowCtx = shadowCtx.parent;
      }

      // 18. All break and continue statements must be contained within the body of a for.
      if (!foundFor)  System.out.println("Error: break and continue must be inside a for loop"); 
    }
  }

  public void exitMethodCall(DecafParser.MethodCallContext ctx) {
    if (ctx.CALLOUT() != null) {
      if (CLI.debug)
        System.out.println("callout to library function: " + ctx.STRINGLITERAL().getText());
    } else {
      // 2. No identifier is used before it is declared.
      String methodName = ctx.methodName().IDENTIFIER().getText();
      MethodSymbol method = (MethodSymbol) currentScope.resolve(methodName);
      if (method == null) {
        System.out.println("Error: method " + methodName + " cannot be found.");

      // 5. The number and types of arguments in a method call must be the same as the number
      // and â€¨types of the formals, i.e., the signatures must be identical
      } else {

        List<DecafParser.ExprContext> suppliedParameters = ctx.expr();
        
        int numOfParamsRequired = method.formalParameters.size();
        int numOfParamsSupplied = suppliedParameters == null ? 0 : suppliedParameters.size();

        if (numOfParamsSupplied == numOfParamsRequired) {
          if (numOfParamsRequired != 0) {
            List<Symbol> paramList = new ArrayList<>(method.formalParameters.values());
            ListIterator formalParametersItr = paramList.listIterator();
            ListIterator suppliedParametersItr = suppliedParameters.listIterator();

            // Iterate over Method's Symbol list (formal parameters) and compare their types 
            // to given types of supplied arguments that are stored in the ParseTreeProperty object.
            while (formalParametersItr.hasNext() && suppliedParametersItr.hasNext()) { 
              VariableSymbol formalParameter = (VariableSymbol) formalParametersItr.next();

              DecafParser.ExprContext suppliedParameter =
                (DecafParser.ExprContext) suppliedParametersItr.next();

              Symbol.Type suppliedParameterType = exprTypes.get(suppliedParameter);

              if (CLI.debug)
                System.out.println("[supplied: " + suppliedParameterType + "] " +
                  "[formal  : " + formalParameter.type + "]");
            
              if (suppliedParameterType != formalParameter.type) 
                System.out.println("Error: type mismatch; " + suppliedParameterType +
                  " given, " + formalParameter.type + " expected.");
            }
          }
        } else  System.out.println("Error: method " + methodName + " expects " + 
                  numOfParamsRequired + " parameters. " + numOfParamsSupplied + " given.");
      }
    }
  }

  public void exitLocation(DecafParser.LocationContext ctx) {
    String locationName = ctx.IDENTIFIER().getText();
    Symbol location = currentScope.resolve(locationName);


    // 9. An id used as a location must name a declared local/global variable or formal parameter.
    if (location == null)
      System.out.println("Error: variable " + locationName + " cannot be found.");
    else {
      // 10. For all locations of the form id[expr];
      if (ctx.LBRACE() != null && ctx.RBRACE() != null) {
        // a) id must be an array variable,
        if (!(location instanceof ArrayVariableSymbol))
          System.out.println("Error: " + locationName + " is not an array.");
        else {
          Symbol.Type exprType = exprTypes.get(ctx.expr());
          // b) the type of <expr> must be int.
          if (exprType != Symbol.Type.INT)
            System.out.println("Error: array index must be an integer.");
        }
      }
    }
  }

  public void enterExpr(DecafParser.ExprContext ctx) {
    if      (ctx.location()       != null)  {
      Symbol identifier = currentScope.resolve(ctx.location().IDENTIFIER().getText());
      if    (identifier           != null)  exprTypes.put(ctx, identifier.type);
      else                                  exprTypes.put(ctx, Symbol.Type.INVALID);
    }
    else if (ctx.INTLITERAL()     != null)  exprTypes.put(ctx, Symbol.Type.INT);    
    else if (ctx.BOOLEANLITERAL() != null)  exprTypes.put(ctx, Symbol.Type.BOOLEAN);
    else if (ctx.STRINGLITERAL()  != null)  exprTypes.put(ctx, Symbol.Type.INVALID);
    else if (ctx.CHARLITERAL()    != null)  exprTypes.put(ctx, Symbol.Type.INVALID);
    else if (ctx.methodCall()     != null) {
      // Callouts return type INT. So the type of the expression containing it will be INT too.
      if    (ctx.methodCall().CALLOUT() != null) exprTypes.put(ctx, Symbol.Type.INT);
      else  {
        exprTypes.put(ctx,
          currentScope.resolve(ctx.methodCall().methodName().IDENTIFIER().getText()).type);
      }
    }
  }

  public void exitExpr(DecafParser.ExprContext ctx) {
    if (ctx.methodCall() != null) {
      if (ctx.methodCall().CALLOUT() == null) {
        String methodName = ctx.methodCall().methodName().IDENTIFIER().getText();
        MethodSymbol method = (MethodSymbol) currentScope.resolve(methodName);
        // 6. If a method call is used as an expression, the method must return a result.
        if (method == null)
          System.out.println("Error: method " + methodName + " cannot be found.");
        else
          if (method.type == Symbol.Type.VOID)
            System.out.println("Error: method " + methodName + " is used as an expression, but has " 
              + method.type + " return type.");
      }
    }
    // This is the case when it's '-1' instead of 'x - 1'; there is only one expression
    else if (ctx.MINUS() != null && ctx.expr().size() == 1) {
      Symbol.Type minusExprType = exprTypes.get(ctx.expr(0));
      if    (minusExprType == Symbol.Type.INT)  exprTypes.put(ctx, Symbol.Type.INT);
      else                                      exprTypes.put(ctx, Symbol.Type.INVALID);
        // System.out.println("Error: bad operand for minus");
    }
    else if (ctx.NOT() != null) {
      Symbol.Type notExprType = exprTypes.get(ctx.expr(0));
      if  (notExprType == Symbol.Type.BOOLEAN)
        exprTypes.put(ctx, Symbol.Type.BOOLEAN);
      else { 
        System.out.println("Error: not ( ! ) operand must be of type boolean.");
        exprTypes.put(ctx, Symbol.Type.INVALID);
      }
    }
    else if (ctx.LPAREN() != null && ctx.RPAREN() != null) {
      Symbol.Type exprType = exprTypes.get(ctx.expr(0));
      exprTypes.put(ctx, exprType);
    }
    else if (arithmaticBinaryOperation(ctx)) {
      Symbol.Type lExprType = exprTypes.get(ctx.expr(0));
      Symbol.Type rExprType = exprTypes.get(ctx.expr(1));

      // 12. The operands of arith_ops and rel_ops must have type int.
      if (lExprType == Symbol.Type.INT && rExprType == Symbol.Type.INT) {
        if (arithmaticReturnsInteger(ctx))
          exprTypes.put(ctx, Symbol.Type.INT);
        else if (arithmaticReturnsBoolean(ctx))
          exprTypes.put(ctx, Symbol.Type.BOOLEAN);
      } else {
        exprTypes.put(ctx, Symbol.Type.INVALID);
        System.out.println("Error: arithmatic operands must be of type integer.");
      }
    }
    else if (equalityBinaryOperations(ctx)) {
      Symbol.Type lExprType = exprTypes.get(ctx.expr(0));
      Symbol.Type rExprType = exprTypes.get(ctx.expr(1));

      // 13. The operands of eq_ops must have the same type, either int or boolean.
      if (lExprType != rExprType)
        System.out.println("Error: boolean operands must be the same type.");

      if (lExprType == Symbol.Type.BOOLEAN && rExprType == Symbol.Type.BOOLEAN
      ||  lExprType == Symbol.Type.INT     && rExprType == Symbol.Type.INT)
        exprTypes.put(ctx, Symbol.Type.BOOLEAN);
      else {
        System.out.println("Error: equality operands must be of type boolean or integer.");
        exprTypes.put(ctx, Symbol.Type.INVALID);
      }
    }
    else if (conditionalBinaryOperation(ctx)) {
      Symbol.Type lExprType = exprTypes.get(ctx.expr(0));
      Symbol.Type rExprType = exprTypes.get(ctx.expr(1));

      // 14. The operands of cond_ops and the operand of logical not (!) must have type boolean.
      if (lExprType == Symbol.Type.BOOLEAN && rExprType == Symbol.Type.BOOLEAN)
        exprTypes.put(ctx, Symbol.Type.BOOLEAN);
      else {
        System.out.println("Error: arithmatic operands must be of type integer.");
        exprTypes.put(ctx, Symbol.Type.INVALID);
      }
    }
  }

  // some arithmatic expressions set the type to different things. Best way to distinguish is here.
  public boolean arithmaticBinaryOperation(DecafParser.ExprContext ctx) {
    return arithmaticReturnsInteger(ctx) || arithmaticReturnsBoolean(ctx);
  }

  public boolean arithmaticReturnsInteger(DecafParser.ExprContext ctx) {
    return  ctx.MULTIPLY()    != null
        ||  ctx.DIVISION()    != null
        ||  ctx.MODULO()      != null
        ||  ctx.ADDITION()    != null
        ||  ctx.MINUS()       != null;
  }

  public boolean arithmaticReturnsBoolean(DecafParser.ExprContext ctx) {
    return  ctx.LESSTHAN()    != null
        ||  ctx.GREATERTHAN() != null
        ||  ctx.LSSTHNEQTO()  != null
        ||  ctx.GRTTHNEQTO()  != null;
  }

  // these can be ints or bools
  public boolean equalityBinaryOperations(DecafParser.ExprContext ctx) {
    return  ctx.EQUAL()      != null
        ||  ctx.NOTEQUAL()  != null;
  }

  // these must be booleans
  public boolean conditionalBinaryOperation(DecafParser.ExprContext ctx) {
    return  ctx.AND() != null
        ||  ctx.OR()  != null;
  }
}